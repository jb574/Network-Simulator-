/**
 * NetSim project
 */

package netsim.Model.Devices;

import com.sun.management.VMOption;
import netsim.GUI.GUIManager;
import netsim.GUI.Window;
import netsim.Simulation.Agent;
import netsim.Model.Devices.Device;
import netsim.View.SignalView;

import java.util.List;
import java.util.Random;
import netsim.GUI.Point;

/**
 * @author: Jack Davey
 * @version: 25/11/2013
 *  This class represents a signal  that
 *  travels along the network
 */
public class Signal extends Agent
{
    protected Wire wire;
    protected Device origin;
    protected Device destination;
    protected boolean empty;
    private int index;
    private String action;
    private int listenTime;
    private int timeListened;
    private String nextAction;
    private boolean newProcess;
    private boolean corrupted;
    private float deltaX, deltaY;
    private boolean direction;
    private Device trueDestination;
    private int amountStillToProcess;
    // this is defffrent form the id
    // in that it signals what point of the comunication this is at
    private int sequenceNumber;
    // this must be the id of a   Communication object held wthin the true destination.
    private int ComNumber;




    /**
     * constructor for  this calsss
     * use this one just befor sending
     * when the place the wire is headed might not
     * be its true destination
     * @param start the origin field
     * @param end the destination
     * @param wire the wire we want to move down
     * @param startAction the  first thing we want this signal to do
     *  @param trueDest the true destination of this device so the pc at the other end can chec
     */
    public Signal(Wire wire, Device start, Device end,String startAction, Device trueDest)
    {
        super();
        trueDestination = trueDest;
        commonConstructorCode(wire, start, end, startAction);
    }



    /**
     * constructor for  this calsss
     * @param start the origin field
     * @param end the destination
     * @param wire the wire we want to move down
     * @param startAction the  first thing we want this signal to do
     */
     public Signal(Wire wire, Device start, Device end,String startAction)
    {
        super();

        trueDestination = null;
        commonConstructorCode(wire, start, end, startAction);
     }

    /**
     * code that is called in
     * all constructors to avoid code dupliaction
     * @param wire this signals wire
     * @param start the sender of this signal
     * @param end  the destination of this signal
     * @param startAction   the  first thing we want this signal to do
     */
    public void commonConstructorCode(Wire wire, Device start, Device end, String startAction) {
        this.wire = wire;
        origin = start;
        destination = end;
        setNewProcess(true);
        empty = false;
        setCorrupted(false);
        action = startAction;
        System.out.println(startAction);
        _view = null;
        amountStillToProcess =0;
    }


    /**
     * constructor for generating empty signals
     */
    public Signal()
    {
        empty = true;
        action = "";
    }


    public static Signal createEmptySignal()
    {
        return new Signal();
    }


    /**
     * overided method generated byt he ide
     * so that we can check equality for signals
     * @param o the other object to check
     * @return  a yes or no answer as to whether
     * these are the same objects
     */
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        if (!super.equals(o)) return false;

        Signal signal = (Signal) o;

        if (destination != null ? !destination.equals(signal.destination) : signal.destination != null) return false;
        if (origin != null ? !origin.equals(signal.origin) : signal.origin != null) return false;
        if (trueDestination != null ? !trueDestination.equals(signal.trueDestination) : signal.trueDestination != null)
            return false;
        if (wire != null ? !wire.equals(signal.wire) : signal.wire != null) return false;

        return true;
    }


    /**
     * method for generating
     * a hash code for signals
     * generated by intellij
     * @return the generated hashcode
     */
    @Override
    public int hashCode() {
        int result = super.hashCode();
        result = 31 * result + (wire != null ? wire.hashCode() : 0);
        result = 31 * result + (origin != null ? origin.hashCode() : 0);
        result = 31 * result + (destination != null ? destination.hashCode() : 0);
        result = 31 * result + (trueDestination != null ? trueDestination.hashCode() : 0);
        return result;
    }

    /**
     * method to set up the view for this object
     * @param start  the starting computer
     * @param end  the ending computer
     */
    public void initView(Device start, Device end) {
        netsim.View.Computer startView = (netsim.View.Computer)start.getView();
        netsim.View.Computer endView = (netsim.View.Computer)end.getView();
        _view = new SignalView(getUID(),startView.getX(),startView.getY());

        deltaX = ((float)endView.getX() - (float)startView.getX()) / (float)this.wire.getSectionCount();
        deltaY = ((float)endView.getY() - (float)startView.getY()) / (float)this.wire.getSectionCount();
        if(direction)
        {
            index = 0;
        }
        else
        {
            index = 20;
        }
    }


    /**
     * this just tells the signal that thats courrped
     */
    public  void  onClick()
    {
        setCorrupted(true);
        SignalView aview = (SignalView) _view;
        aview.displayCollision();
    }

    /**
     * method to check whether a singal has
     * collided
     * @return the signal that was collidex with
     */
    public Signal checkCollision()
    {
        if(index > 0)
        {
            List<Signal> signals = wire.getSignals();
            for(Signal sig : wire.getSignals())
            {
                if(sig.getIndex() == index && !sig.equals(this))
                {
                    return  sig;
                }
            }

        }
        return  null;
    }




    /**
     * method to  reset this agent
     * in this case it kills it
     */
    @Override
    public void reset()
    {
        kill();
    }

    public Device getTrueDestination() {
        return trueDestination;
    }

    public void setTrueDestination(Device trueDestination) {
        this.trueDestination = trueDestination;
    }

    /**
     * Called when we should do something
     */
    protected void onTick() {

        if (action.equals("move"))
        {
            moveSignal();
        }


        if(action.equals("back"))
        {
            _view = null;
            wire.removeOldSignal(this);
            retransmitSignal(this);


        }
        if(action.equals("wait"))
        {
            action = "back";
        }
        if(action == "old")
        {
            origin.takeCorruptedMessage(this);
            action = "send";
            _view = null;
        }

    }


    /**
     * method to move the signal down the wire
     * and deal with any collisions that occour
     */
    private void moveSignal()
    {
        if(_view == null)
        {
            initView(origin,destination);
        }
        SignalView aview = (SignalView) _view;
        aview.update(deltaX, deltaY);
        System.out.println("current index for sig" + getUID() + "is"
        + index);
        if(direction)
        {
            index = index+1;
        }
        else
        {
            index = index-1;
        }
        ignoreTicks(1);
        Signal newSig = checkCollision();
        if(newSig != null)
        {
            action = "wait";
            GUIManager.addText(" signals " + this.getUID()  + " and "
                    + newSig.getUID()
                    + "have collided and will need to be resent!");
            System.out.println("bang");
            retransmitSignal(newSig);
            newSig.setView(null);
            wire.removeOldSignal(newSig);
            wire.removeOldSignal(this);
            ignoreTicks(1);
            aview.displayCollision();

        }
        if (index >= wire.getSectionCount() || index <= 0){
            _view = null;
            wire.removeOldSignal(this);
            action = "";
            if(destination.canProcessSigNow())
            {
                destination.recieveMessage(this);
            }
            else
            {
                setNewProcess(false);
                aview.displayCollision();
                ignoreTicks(3);
                action= "old";
            }
        }
    }

    /**
     * method to restransmit
     * a signal after a collision
     * @param the signal to retransmit
     */
    private void retransmitSignal(Signal sig)
    {
        Random machine = new Random();
        int backoffTime = machine.nextInt(10);
        sig.setNewProcess(false);
        sig.setAction("listen");
        sig.getOrigin().backoff(backoffTime,sig);
        sig.setIndex(1);
    }


    /**
     * method for disabling the signal
     */
        public  void disableSignalGraphics()
        {
            this._view = null;
        }


    public void setAmountStillToProcess(int amountStillToProcess) {
        this.amountStillToProcess = amountStillToProcess;
    }

    public int getAmountStillToProcess()
    {
        return amountStillToProcess;
    }

    /**
     * this gets the origin
     * of this signal
     * @return  the origin as described above
     */
    public Device getOrigin()
    {
        return origin;
    }

    public String getAction()
    {
        return action;
    }

    public void setAction(String action)
    {
        this.action = action;
    }

    public int getIndex()
    {
        return index;
    }

    public void setIndex(int index)
    {
        this.index = index;
    }

     public boolean isOccupied()
     {
        return  (isEmpty() == false);
     }

    public boolean isDirection()
    {
        return direction;
    }

    public void setDirection(boolean direction)
    {
        this.direction = direction;
    }

    public boolean isNewProcess() {
        return newProcess;
    }

    public void setNewProcess(boolean newProcess) {
        this.newProcess = newProcess;
    }

    public boolean isCorrupted() {
        return corrupted;
    }

    public void setCorrupted(boolean corrupted) {
        this.corrupted = corrupted;
    }

    public int getComNumber() {
        return ComNumber;
    }

    public void setComNumber(int comNumber) {
        ComNumber = comNumber;
    }

    public int getSequenceNumber() {
        return sequenceNumber;
    }

    public void setSequenceNumber(int sequenceNumber) {
        this.sequenceNumber = sequenceNumber;
    }

    /**
     * this gets the destination fo this signal
     * @return  the destination as described above
     */
    public Device getDestination()
    {
        return destination;
    }

    public boolean isEmpty()
    {
        return empty;
    }

    public void setEmpty(boolean empty)
    {
        this.empty = empty;
    }


    public int getTimeListened()
    {
        return timeListened;
    }

    public void setTimeListened(int timeListened)
    {
        this.timeListened = timeListened;
    }

    public int getListenTime()
    {
        return listenTime;
    }

    public void setListenTime(int listenTime)
    {
        this.listenTime = listenTime;
    }

    public String getNextAction()
    {
        return nextAction;
    }

    public void setNextAction(String nextAction)
    {
        this.nextAction = nextAction;
    }

    public Wire getWire() {
        return wire;
    }
}
